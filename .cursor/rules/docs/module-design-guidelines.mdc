---
description: Module design documentation guidelines (模块设计文档规范 - 主文档)
globs: []
alwaysApply: false
---
最近更新: 2025-10-28
最近审阅: 2025-10-28
# Module Design Documentation Guidelines

> **核心理念**：结构化表达 + 图示优先 + 可裁剪 + 设计原则驱动
> 
> **文件编码**：所有文档统一使用 UTF-8 编码，无 BOM
> 
> **目标**：通过清晰的设计原则和文档规范，确保模块设计质量和团队协作效率

## 📚 文档导航

本规范已拆分为多个文档，方便按需查阅：

| 文档 | 内容 | 适用场景 |
|------|------|----------|
| 📖 **当前文档** | 核心设计原则、文档概述、七要素框架 | 设计前必读 |
| 📘 [七要素详细规范](./module-seven-elements.mdc) | 第3-9章：背景、角色、模型、流程、状态、接口、数据 | 详细设计阶段 |
| 📙 [质量保障指南](./module-quality-assurance.mdc) | 第10-15章：NFR、监控、安全、风险 | 质量评审阶段 |
| 📕 [工程实践指南](./module-engineering-practices.mdc) | 第16-24章：技术债、评审、演进、快速指南 | 工程实践阶段 |

---

## 0. 核心设计原则

### 0.1 通用设计原则（SOLID + 经典原则）

#### SOLID 原则
| 原则 | 含义 | 模块设计应用 | 反模式示例 |
|------|------|--------------|-----------|
| **S**ingle Responsibility | 单一职责 | 一个模块只负责一个业务能力或领域概念 | 订单模块既管理订单又处理支付和库存 |
| **O**pen/Closed | 开闭原则 | 通过扩展而非修改来应对变化（策略模式、插件机制） | 每次新增支付方式都要修改核心支付流程 |
| **L**iskov Substitution | 里氏替换 | 子类/实现类可替换父类/接口而不影响系统正确性 | 继承关系破坏了父类的不变量约束 |
| **I**nterface Segregation | 接口隔离 | 客户端不应依赖它不需要的接口 | 一个接口包含读、写、审计、统计所有方法 |
| **D**ependency Inversion | 依赖倒置 | 依赖抽象而非具体实现；高层模块不依赖低层模块 | Service 直接依赖具体的 MySQLRepository |

#### 其他核心原则
| 原则 | 说明 | 模块设计检查点 |
|------|------|----------------|
| **DRY** (Don't Repeat Yourself) | 避免重复逻辑和知识 | 相同的业务规则是否在多处重复？ |
| **KISS** (Keep It Simple, Stupid) | 保持简单 | 是否过度设计？能用简单方案解决吗？ |
| **YAGNI** (You Aren't Gonna Need It) | 不要过度设计未来需求 | 是否实现了当前不需要的功能？ |
| **高内聚，低耦合** | 模块内部紧密相关，模块间松散依赖 | 模块之间的依赖关系是否清晰最小？ |
| **最少知识原则** (Law of Demeter) | 只与直接朋友通信 | 是否存在跨多层的方法调用链？ |

### 0.2 领域驱动设计（DDD）原则

#### 战略设计原则
```mermaid
graph TB
    subgraph "限界上下文 Bounded Context"
        A[订单上下文] --> |发布事件| B[支付上下文]
        B --> |发布事件| C[库存上下文]
        D[用户上下文] -.防腐层.-> A
    end
    style A fill:#e0f2fe
    style B fill:#dbeafe
    style C fill:#bfdbfe
    style D fill:#93c5fd
```

| DDD 概念 | 定义 | 模块设计应用 | 关键检查 |
|----------|------|--------------|----------|
| **限界上下文** | 明确的业务边界，内部术语统一 | 每个模块对应一个限界上下文 | 是否存在术语冲突？边界是否清晰？ |
| **聚合根** | 保证数据一致性的边界 | 一个聚合内的修改必须原子性 | 聚合是否过大？是否跨聚合事务？ |
| **实体 Entity** | 有唯一标识的领域对象 | 订单、用户、商品 | 标识是否唯一？生命周期是否清晰？ |
| **值对象 Value Object** | 无标识，不可变的领域概念 | 金额、地址、时间范围 | 是否不可变？是否可替换？ |
| **领域事件** | 已发生的业务事实 | 订单已创建、支付已完成 | 事件命名是否过去时？是否幂等？ |
| **领域服务** | 跨实体的业务逻辑 | 订单结算、库存分配 | 是否无状态？是否业务语义清晰？ |
| **仓储 Repository** | 聚合的持久化抽象 | UserRepository, OrderRepository | 是否只操作聚合根？是否隐藏存储细节？ |
| **防腐层 ACL** | 保护本领域模型不被外部污染 | 适配外部API的数据模型 | 是否隔离了外部模型变化影响？ |

#### 战术设计原则
```mermaid
classDiagram
    class Order {
        <<AggregateRoot>>
        +OrderId id
        +OrderStatus status
        +Money totalAmount
        +List~OrderItem~ items
        +placeOrder()
        +cancel()
        +checkInvariant()
    }
    class OrderItem {
        <<Entity>>
        +ItemId id
        +ProductId productId
        +Quantity quantity
        +Money price
    }
    class Money {
        <<ValueObject>>
        +BigDecimal amount
        +Currency currency
        +add(Money other)
    }
    class OrderStatus {
        <<Enum>>
        DRAFT
        PLACED
        PAID
        CANCELLED
    }
    Order "1" *-- "*" OrderItem : contains
    Order --> Money : uses
    Order --> OrderStatus : has
```

**聚合设计原则**：
- ✅ **小聚合优于大聚合**：聚合越小，并发冲突越少
- ✅ **通过ID引用其他聚合**：不要在一个聚合内嵌套另一个聚合
- ✅ **在聚合边界内保证一致性**：跨聚合用最终一致性
- ✅ **聚合根是唯一入口**：外部只能通过聚合根修改内部实体

### 0.3 API 设计原则

#### RESTful 设计原则
| 原则 | 说明 | 良好示例 | 反模式 |
|------|------|----------|--------|
| **资源导向** | URL 表示资源，而非动作 | `GET /orders/{id}` | `GET /getOrder?id=123` |
| **统一接口** | 使用标准 HTTP 方法 | `DELETE /orders/{id}` | `POST /deleteOrder` |
| **无状态** | 每个请求包含完整信息 | 请求带 token | Session 依赖 |
| **可缓存性** | 响应明确是否可缓存 | `Cache-Control: max-age=3600` | 无缓存头 |
| **分层系统** | 客户端不关心中间层 | 透明代理/网关 | 客户端直连数据库 |
| **按需代码**（可选） | 服务端可发送可执行代码 | 返回前端组件配置 | - |

#### API 版本管理原则
- **向后兼容优先**：新增字段可选，不删除或重命名已有字段
- **版本策略**：URL版本（`/api/v1/orders`）或 Header 版本
- **废弃流程**：标记废弃 → 公告期 → 灰度下线 → 完全移除
- **多版本共存**：支持 v1、v2 同时运行，给客户迁移时间

#### 幂等性设计原则
| HTTP 方法 | 是否幂等 | 幂等性保证方式 | 示例 |
|-----------|----------|----------------|------|
| GET | ✅ 天然幂等 | 只读操作 | 查询订单 |
| PUT | ✅ 天然幂等 | 全量更新 | 更新订单地址 |
| DELETE | ✅ 天然幂等 | 删除操作 | 删除订单（重复删除返回404） |
| POST | ❌ 非幂等 | **需要设计** | 创建订单需幂等键 |
| PATCH | ⚠️ 视情况 | 部分更新需幂等键 | 增加库存（需要版本号） |

**POST 幂等性实现方案**：
1. **客户端幂等Token**：`Idempotency-Key` header
2. **业务唯一键**：订单号、交易流水号
3. **乐观锁**：version 字段防止并发修改

### 0.4 数据建模原则

#### 数据库设计原则
| 原则 | 说明 | 检查点 |
|------|------|--------|
| **范式化权衡** | OLTP 适度范式（2NF~3NF），OLAP 可反范式 | 是否有合理的冗余？是否过度范式导致复杂join？ |
| **主键设计** | 使用代理主键（自增ID、UUID、雪花ID） | 是否暴露业务含义导致变更？ |
| **索引策略** | 查询优先，写入性能兼顾 | 是否分析了查询模式？是否有冗余索引？ |
| **约束优先** | 使用 NOT NULL、UNIQUE、CHECK 约束 | 是否依赖应用层校验？是否有数据一致性风险？ |
| **时区统一** | 统一使用 UTC 时间存储 | 是否使用 TIMESTAMP/DATETIME？是否考虑时区转换？ |
| **软删除** | 使用 deleted_at 而非物理删除 | 是否需要审计？是否需要恢复功能？ |

#### 数据类型选择原则
| 业务场景 | 推荐类型 | 避免使用 | 原因 |
|----------|----------|----------|------|
| **金额** | `DECIMAL(19,4)` | `FLOAT/DOUBLE` | 避免精度丢失 |
| **状态** | `VARCHAR(50)` 或 `TINYINT` | `ENUM` | 扩展性好 |
| **日期时间** | `TIMESTAMP` (UTC) | `DATETIME` 无时区 | 时区转换 |
| **布尔值** | `BOOLEAN/TINYINT(1)` | `VARCHAR` | 类型安全 |
| **大文本** | `TEXT/LONGTEXT` | `VARCHAR(MAX)` | 适合内容 |
| **JSON** | `JSON` 列类型 | `TEXT` 序列化 | 支持索引和查询 |

### 0.5 并发与性能设计原则

#### 并发控制原则
```mermaid
graph LR
    A[并发场景] --> B{冲突频率?}
    B -->|低| C[乐观锁 version]
    B -->|高| D{等待时间?}
    D -->|短| E[悲观锁 FOR UPDATE]
    D -->|长| F[分布式锁 Redis]
    B -->|极高| G[队列串行化]
    style C fill:#86efac
    style E fill:#fde047
    style F fill:#fca5a5
    style G fill:#c7d2fe
```

| 策略 | 适用场景 | 优点 | 缺点 | 实现方式 |
|------|----------|------|------|----------|
| **乐观锁** | 冲突少的场景 | 无锁开销 | 冲突时需重试 | version 字段 |
| **悲观锁** | 冲突多的短事务 | 保证成功 | 阻塞等待 | SELECT FOR UPDATE |
| **分布式锁** | 跨实例的资源控制 | 强一致性 | 复杂度高 | Redis SETNX |
| **队列串行化** | 高并发秒杀 | 削峰填谷 | 延迟高 | 消息队列 |

#### 性能设计原则
- **避免N+1查询**：使用批量查询或JOIN
- **合理使用缓存**：读多写少场景，注意缓存一致性
- **异步化**：耗时操作异步处理，快速返回
- **分页查询**：大数据量必须分页，限制最大页大小
- **连接池**：数据库、Redis、HTTP 客户端统一使用连接池
- **超时控制**：所有外部调用设置合理超时时间

### 0.6 可观测性设计原则

#### 日志分级原则
| 级别 | 使用场景 | 内容要求 | 频率控制 |
|------|----------|----------|----------|
| **ERROR** | 系统错误，需要立即处理 | 完整异常栈 + traceId | 告警 |
| **WARN** | 业务异常，需要关注 | 关键参数 + 原因 | 监控 |
| **INFO** | 重要业务节点 | 简洁业务信息 | 适度 |
| **DEBUG** | 调试信息 | 详细调试数据 | 仅开发环境 |

#### 指标设计原则（RED + USE）
**RED 方法**（面向请求）：
- **Rate**: 请求速率（QPS）
- **Errors**: 错误率（Error Rate）
- **Duration**: 响应时间（P50/P95/P99）

**USE 方法**（面向资源）：
- **Utilization**: 资源利用率（CPU、内存、连接池）
- **Saturation**: 资源饱和度（队列长度）
- **Errors**: 错误计数

#### 链路追踪原则
- **入口生成 TraceId**：网关或第一个服务生成
- **跨服务传递**：通过 HTTP Header 或消息属性传递
- **关键节点打点**：数据库查询、外部调用、关键业务逻辑
- **采样策略**：生产环境采样率 1%~10%，问题排查时 100%

### 0.7 安全设计原则

#### 纵深防御原则
```mermaid
graph TB
    A[客户端] --> B[WAF/API网关]
    B --> C[身份认证 Authentication]
    C --> D[授权 Authorization]
    D --> E[输入校验]
    E --> F[业务逻辑]
    F --> G[数据访问]
    G --> H[审计日志]
    style B fill:#fecaca
    style C fill:#fed7aa
    style D fill:#fde68a
    style E fill:#d9f99d
    style F fill:#a7f3d0
    style G fill:#99f6e4
    style H fill:#a5f3fc
```

#### 核心安全原则
| 原则 | 说明 | 实施要点 |
|------|------|----------|
| **最小权限** | 只授予完成任务所需的最小权限 | RBAC 细粒度权限控制 |
| **纵深防御** | 多层防护，不依赖单点 | 网关+应用+数据多层校验 |
| **默认拒绝** | 白名单机制，未明确允许即拒绝 | 权限系统默认无权限 |
| **失败安全** | 出错时保持安全状态 | 认证失败返回 401，而非 500 |
| **审计完整** | 记录所有安全相关操作 | 登录、权限变更、敏感操作 |
| **数据脱敏** | 敏感信息不明文存储/传输 | 手机号、身份证、密码加密/脱敏 |

#### 常见安全威胁与防护
| 威胁 | 防护措施 | 检查点 |
|------|----------|--------|
| **SQL 注入** | 参数化查询，不拼接 SQL | 是否使用 PreparedStatement？ |
| **XSS** | 输出转义，CSP 策略 | 是否对用户输入进行转义？ |
| **CSRF** | Token 验证，SameSite Cookie | 是否有 CSRF Token？ |
| **越权访问** | 资源权限校验 | 是否检查用户对资源的权限？ |
| **敏感信息泄露** | 脱敏、加密、HTTPS | 日志是否输出了敏感信息？ |
| **DDoS** | 限流、熔断、降级 | 是否有限流机制？ |

### 0.8 设计原则检查清单

在完成模块设计后，使用以下检查清单验证：

#### 职责与边界
- [ ] 模块职责是否单一明确？（SRP）
- [ ] 限界上下文边界是否清晰？
- [ ] 是否存在跨边界的数据依赖？

#### 扩展性
- [ ] 是否通过扩展而非修改来应对变化？（OCP）
- [ ] 是否使用了策略模式等扩展机制？
- [ ] 配置是否外部化？

#### 依赖关系
- [ ] 是否依赖抽象而非具体实现？（DIP）
- [ ] 依赖方向是否正确（高层不依赖低层）？
- [ ] 是否有循环依赖？

#### 数据与状态
- [ ] 聚合大小是否合理（不超过3层）？
- [ ] 是否通过ID引用其他聚合？
- [ ] 状态转换是否有明确的守卫条件？
- [ ] 并发控制策略是否清晰？

#### 接口设计
- [ ] API 是否符合 RESTful 规范？
- [ ] 是否设计了幂等性保证？
- [ ] 错误码是否有明确的范围和含义？
- [ ] 是否有向后兼容策略？

#### 可观测性
- [ ] 是否定义了关键指标（QPS、错误率、延迟）？
- [ ] 是否有 TraceId 传递机制？
- [ ] 日志级别是否合理？
- [ ] 是否有告警阈值？

#### 安全性
- [ ] 是否有认证和授权机制？
- [ ] 敏感数据是否加密/脱敏？
- [ ] 是否防范了常见安全威胁？
- [ ] 是否有审计日志？

---

## 1. 文档概述与使用指南

### 1.1 文档目的
本文档旨在提供：
- **系统化的设计原则**：确保模块设计质量和一致性
- **标准化的文档模板**：降低沟通成本，提高协作效率
- **可裁剪的规范**：根据项目复杂度灵活调整文档深度
- **设计评审检查清单**：保证设计评审的完整性和有效性

### 1.2 适用场景
| 场景 | 使用文档 | 说明 |
|------|----------|------|
| **新模块设计** | 全部4个文档 | 完整设计流程，从原则到实施 |
| **现有模块重构** | 主文档 + 工程实践 | 设计原则 + 检查清单 + 评审流程 |
| **API设计** | 主文档(0.3节) + 七要素(第8章) | API设计原则 + 接口契约规范 |
| **数据建模** | 主文档(0.4节) + 七要素(第9章) | 数据建模原则 + 存储设计 |
| **性能优化** | 主文档(0.5节) + 质量保障 | 性能原则 + NFR规范 |
| **安全加固** | 主文档(0.7节) + 质量保障 | 安全原则 + 安全控制 |
| **设计评审** | 主文档 + 工程实践 | 设计原则 + 检查清单 + 评审流程 |

### 1.3 文档结构
```mermaid
graph TB
    A[📖 主文档<br/>核心设计原则<br/>文档概述<br/>七要素框架] --> B[📘 七要素详细]
    A --> C[📙 质量保障]
    A --> D[📕 工程实践]
    
    B --> B1[背景与目标]
    B --> B2[角色与用例]
    B --> B3[模型与不变量]
    B --> B4[流程与时序]
    B --> B5[状态机设计]
    B --> B6[接口与事件]
    B --> B7[数据存储]
    
    C --> C1[NFR]
    C --> C2[错误处理]
    C --> C3[监控]
    C --> C4[安全]
    C --> C5[迁移]
    C --> C6[风险]
    
    D --> D1[技术债]
    D --> D2[裁剪准则]
    D --> D3[自检清单]
    D --> D4[反模式]
    D --> D5[评审流程]
    D --> D6[版本演进]
    D --> D7[快速指南]
    
    style A fill:#fca5a5
    style B fill:#86efac
    style C fill:#fde047
    style D fill:#93c5fd
```

### 1.4 阅读建议

#### 首次使用者
1. **熟悉设计原则**（30分钟）：阅读主文档第0章，理解核心设计理念
2. **了解文档框架**（15分钟）：阅读主文档第1-2章，掌握文档结构
3. **学习七要素**（1小时）：阅读[七要素详细规范](./module-seven-elements.mdc)
4. **实践应用**（按需）：参考[工程实践指南](./module-engineering-practices.mdc)

#### 有经验的设计者
- **快速参考**：使用[工程实践指南](./module-engineering-practices.mdc)第23章快速填写指南
- **深入特定领域**：根据需要查阅对应文档
- **评审检查**：使用[工程实践指南](./module-engineering-practices.mdc)第18章和第21章

#### 评审者
- **设计评审**：使用主文档第0.8节检查清单
- **文档质量评审**：使用[工程实践指南](./module-engineering-practices.mdc)第18章
- **风险评估**：关注[质量保障指南](./module-quality-assurance.mdc)

### 1.5 文档维护
- **更新频率**：随技术栈和团队实践演进而更新
- **版本控制**：所有修订需记录在文档头部
- **评审机制**：重大修订需经团队评审通过
- **反馈渠道**：鼓励团队成员提出改进建议

---

## 2. 七要素总览

### 2.1 七要素框架
```mermaid
flowchart LR
  A[3 背景与目标] --> B[4 角色与用例]
  B --> C[5 模型与不变量]
  C --> D[6 流程与时序]
  D --> E[7 状态机设计]
  E --> F[8 接口与事件契约]
  F --> G[9 数据存储设计]
  classDef core fill:#0369a1,stroke:#0c4a6e,color:#fff,stroke-width:1
  class A,B,C,D,E,F,G core
```

> **详细内容请参考**：[七要素详细规范](./module-seven-elements.mdc)

### 2.2 七要素映射关系
| 要素 | 章节 | 核心问题 | 输出物 | 检查点 |
|------|------|----------|--------|--------|
| **Why** (目标) | 第3章 | 为什么需要这个模块？ | 目标、非目标、度量指标 | 是否可量化？ |
| **Who** (角色) | 第4章 | 谁会使用？怎么使用？ | 角色、用例、时序图 | 是否覆盖主路径和异常？ |
| **What** (模型) | 第5章 | 核心概念是什么？ | 领域模型、不变量、关系图 | 聚合是否合理？ |
| **How** (流程) | 第6章 | 如何实现业务流程？ | 时序图、流程图 | 是否有补偿机制？ |
| **How** (状态) | 第7章 | 状态如何转换？ | 状态机图、转换表 | 守卫条件是否完备？ |
| **Expose** (接口) | 第8章 | 如何对外暴露？ | API契约、事件定义 | 是否幂等？是否兼容？ |
| **Persist** (数据) | 第9章 | 如何持久化？ | 表设计、索引策略 | 是否有索引？是否分区？ |

### 2.3 七要素设计流程
```mermaid
graph TD
    Start([开始设计]) --> Goal[3. 明确目标与非目标]
    Goal --> UseCase[4. 识别角色与用例]
    UseCase --> Model[5. 建立领域模型]
    Model --> Flow[6. 设计业务流程]
    Flow --> State[7. 设计状态机]
    State --> API[8. 设计接口契约]
    API --> Data[9. 设计数据存储]
    Data --> Quality[10-15. 质量保障]
    Quality --> Practice[16-24. 工程实践]
    Practice --> Review[评审与迭代]
    Review --> |通过| Done([完成])
    Review --> |不通过| Goal
    
    style Goal fill:#fef3c7
    style Model fill:#dbeafe
    style API fill:#ddd6fe
    style Data fill:#fecaca
    style Quality fill:#d1fae5
    style Practice fill:#93c5fd
```

### 2.4 领域模型示例
```mermaid
classDiagram
    direction LR
    class AggregateRoot {
        <<AggregateRoot>>
        +id: ID
        +version: int
        +createdAt: Timestamp
        +updatedAt: Timestamp
        +checkInvariant()
    }
    class Entity {
        <<Entity>>
        +id: ID
        +aggregateId: ID
        +businessValue: Value
        +status: Enum
    }
    class ValueObject {
        <<ValueObject>>
        +attribute1: Type
        +attribute2: Type
        +equals(other)
    }
    class DomainEvent {
        <<Event>>
        +eventId: UUID
        +aggregateId: ID
        +occurredAt: Timestamp
    }
    AggregateRoot "1" *-- "*" Entity : contains
    AggregateRoot --> ValueObject : uses
    AggregateRoot ..> DomainEvent : publishes
    
    note for AggregateRoot "聚合根是\n一致性边界"
    note for ValueObject "值对象\n不可变"
```

---

## 下一步

根据你的设计阶段，请查阅对应文档：

1. **详细设计阶段** → 查看[七要素详细规范](./module-seven-elements.mdc)
2. **质量评审阶段** → 查看[质量保障指南](./module-quality-assurance.mdc)
3. **工程实践阶段** → 查看[工程实践指南](./module-engineering-practices.mdc)

---

## 文档修订历史

- **2025-10-28**：文档拆分优化
  - 将原 1414 行文档拆分为4个独立文档
  - 主文档：核心设计原则、文档概述、七要素框架（当前文档）
  - 新增文档导航和跨文档引用
  - 优化文档结构，方便按需查阅

- **2025-10-28**：完成文档结构性重构（原版本）
  - 新增第0章核心设计原则
  - 文档章节从13章扩展为24章
  - 形成完整的模块设计方法论体系

- **2025-10-17**：初始版本
  - 定义七要素模块设计框架
  - 提供 Mermaid 图表模板
  - 建立基本文档结构
